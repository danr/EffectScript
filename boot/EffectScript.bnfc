comment "//";
comment "/*" "*/";

Program. Program::= [Decl];

separator Case "";
separator Con "";
separator Decl "";
separator Name ",";
separator nonempty Type ",";
separator TypeParam ",";
separator Param ",";

Algebraic. Decl ::= "type" DeclHead "{" [Con] "}";
Effect.    Decl ::= "effect" DeclHead "{" [Con] "}";
Alias.     Decl ::= "alias" DeclHead "=" Type;
Expr.      Decl ::= Expr2;
_.         Decl ::= Decl ";";

Nul.   Con ::= Name OptType;
NulEx. Con ::= NameK [Name] ">" OptType;
Con.   Con ::= NameP [TypeParam] ")" OptType;
ConEx. Con ::= NameK [Name] ">(" [TypeParam] ")" OptType;
_.     Con ::= Con ";";

ExprRhs. Rhs ::= Expr4;
DeclRhs. Rhs ::= "{" [Decl] "}";

Function.  Expr14 ::= "function" FunctionHead ")" OptType "{" [Decl] "}";
Lit.       Expr14 ::= Lit;
NameMono.  Expr14 ::= Name;
NamePoly.  Expr14 ::= NameK [Type] ">";
WildP.     Expr14 ::= "_";

Switch.    Expr14 ::= "switch" Expr3 "{" [Case] "}";
NSwitch.   Expr14 ::= "switch" "{" [Case] "}";

Call.      Expr14 ::= NameP [Expr] ")";
CallTy.    Expr14 ::= NameK [Type] ">(" [Expr] ")";
Apply.     Expr14 ::= "(" Expr ")(" [Expr] ")";
ApplyT.    Expr14 ::= "(" Expr ")<" [Type] ">";
ApplyTE.   Expr14 ::= "(" Expr ")<" [Type] ">(" [Expr] ")";
separator nonempty Expr ")(";

Mul.  Expr8  ::= Expr8 "*"  Expr9;
Div.  Expr8  ::= Expr8 "/"  Expr9;
Mod.  Expr8  ::= Expr8 "%"  Expr9;
Add.  Expr7  ::= Expr7 "+"  Expr8;
Sub.  Expr7  ::= Expr7 "-"  Expr8;
Eq.   Expr5  ::= Expr6 "==" Expr6;
Ne.   Expr5  ::= Expr6 "!=" Expr6;
Lt.   Expr5  ::= Expr6 "<"  Expr6;
Le.   Expr5  ::= Expr6 "<=" Expr6;
Gt.   Expr5  ::= Expr6 ">"  Expr6;
Ge.   Expr5  ::= Expr6 ">=" Expr6;

Lambda.    Expr4  ::= Expr12 "=>" Rhs;
Let.       Expr4  ::= Expr12 "=" Rhs;
Comma.     Expr3  ::= Expr4 "," Expr3;
Signature. Expr2  ::= Expr3 ":" Type;
Lambda0.   Expr2  ::= "{" [Decl] "}";
            -- ^ low to not conflict with Rhs, can be improved to have { } next to binary operators
Unit.      Expr   ::= ;


coercions Expr 14;

Integer. Lit ::= Integer;
String.  Lit ::= String;

Case. Case ::= "case" Expr3 ":" [Decl];

NameTy.    Type3 ::= Name ;
AppTy.     Type3 ::= NameK [Type] ">" ;
ArrTy.     Type1 ::= Type2 "->" Type1;
ArrTys.    Type1 ::= "(" [Type] ")" "->" Type1;
Bang.      Type2 ::= Type2 "!" Type3;
BangOnly.  Type2 ::= "!" Type3;
UnitTy.    Type3 ::= "(" ")";

coercions Type 3;

NoType. OptType ::= ;
Type.   OptType ::= ":" Type;

MonoHead. DeclHead ::= Name;
PolyHead. DeclHead ::= NameK [Name] ">";

Param.          Param ::= Expr14;
ParamWithType.  Param ::= Expr14 ":" Type;

Anonymous.        FunctionHead ::= "(" [Param] ;
MonoFunctionHead. FunctionHead ::= NameP [Param] ;
PolyFunctionHead. FunctionHead ::= NameK [Name] ">(" [Param] ;

OnlyType.  TypeParam ::= Type;
WithName.  TypeParam ::= Name ":" Type;

position token Name (letter)(letter|digit|["!@$_-?/'"])*;
position token NameP (letter)(letter|digit|["!@$_-?/'"])*(["("]);
position token NameK (letter)(letter|digit|["!@$_-?/'"])*(["<"]);
